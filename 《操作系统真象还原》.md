# 《操作系统真象还原》

## 第0章 一些你可能正感到迷惑的问题

### 0.1操作系统是什么

如果有一个部落，操作系统相当于管理部落的，协调部落各个人员，保证每天的生产工作有条不紊的进行着。具体一点的说，操作系统负责把资源交给用户进程，使用户进程可以专注于自己的工作，而不用考虑如何获取内存中需要的资源，同时为了保证资源的安全性和完整性，用户进程无法直接访问内存。

eg. Linux系统中的内存管理，分别记录哪些page是Active，哪些是“脏页”。但不记录也不会影响程序的正常运行，记录这些状态是为了更好地管理内存，比如结婚要登记，不登记也不影响两个人在一起，但是登记了方便预测国家未来人口趋势。



### 0.4软件是如何访问硬件

显卡是是显示器的适配器，CPU不直接和显示器交互，它只和显卡通信，显卡的内存叫显存，往显存上写字节就是往显示器打印内容。

访问IO接口本质上就是访问IO接口上的寄存器。



### 0.5应用程序是什么，和操作系统是如何配合到一起的

- 应用程序和操作系统都是软件。

- 操作系统是人想出来的，为了让自己管理计算机方便而创造出来的一套管理办法。

- 应用程序要用某种语言编写，而语言又是编译器来提供的。其实根本就没有什么语言，有的只是编译 器。是编译器决定怎样解释某种关键字及某种语法。

- 应用程序加上操作系统提供功能才算是完整的程序。

- 用户态与内核态是对 CPU 来讲的，是指 CPU 运行在用户态（特权 3 级）还是内核态（特权 0 级）， 很多人误以为是对用户进程来讲的。

- 用户进程陷入内核态是指：由于内部或外部中断发生，当前进程被暂时终止执行，其上下文被内核的 中断程序保存起来后，开始执行一段内核的代码。是内核的代码，不是用户程序在内核的代码，用户代码 怎么可能在内核中存在，所以“用户态与内核态”是对 CPU 来说的。操作系统是独立的部分，用户进程永远不会因为进入内核态而变身为操作系统了。（中断用户程序进程，运行内核程序进程，二者完全不同）

### 0.6为什么称为“陷入”内核

![image-20230129232924749](C:\Users\86135\OneDrive\文档\操作系统\OS-img\1.png)

用户程序想要访问系统资源时（无论是硬件，还是内核数据结构），需要进行系统调用。这样CPU就进入了内核态（需要CPU

需要去访问内存），也叫管态。



### 0.7内存访问为什么要分段

- 内存是随机读写设备，即访问其内部任何一处，不需要从头开始找，只需要直接给出地址即可。

- 分段是内存访问机制，是给CPU用的访问内存的方式，只有CPU才关注段。

- 历史遗留问题：之前的计算机没有虚拟地址一说，只有物理地址，于是程序的指令如果想要在硬件上运行，那也必须是绝对物理地址，就要遵从硬件的规则，操作系统和编译器也不例外。于是两个编译出来地址相同的用户程序无法同时运行，只能运行其中一个。

- 解决方式：让CPU采用“段基址+段内偏移地址”的方式来访问任意内存，使程序重定位。

- 重定位：将程序中的指令地址改写成另外一个地址，但新地址的内容还是原地址的内容。CPU 采用“段基址+段内偏移地址”的形式访问内存，就需要专门提供段基址寄存器，这些是 cs、ds、 es 等。程序中需要用到哪块内存，只要先加载合适的段到段基址寄存器中，再给出相对于该段基址的偏移 地址便可，CPU 中的地址单元会将这两个地址相加后的结果用于内存访问，送上地址总线。段基址可以是任意的，不一定要是65536的倍数，因此段可以重叠。

- 程序分段又是为了将大内存分成可以访问的小段， 通过这样变通的方法便能够访问到所有内存了。

- 1M 是 2 的 20 次方，1MB 内存需要 20 位的地址 才能访问到，如何做到用 16 位寄存器访问 20 位地址空间呢？

  这是因为 CPU 设计者在地址处理单元中动了手脚，该地址部件接到“段基址+段内偏移地址”的地址后， 自动将段基址乘以 16，即左移了 4 位，然后再和 16 位的段内偏移地址相加。

### 0.8代码中为什么分为代码段、数据段？这和内存访问机制中的段是一回事吗

- 程序不是一定要分段才能运行，分段只是为了美观。
- 数据和代码分开的好处：
  1. 可以为它们赋予不同的属性：可读可写
  2. 提高CPU内部缓存命中率：程序的局部性原理
  3. 节省内存：共享重复使用的代码段
- 编译器它将程序中那些只读的代码编译出来后，放在 一片连续的区域，这个区域叫代码段。将那些已经初始化的数据也放在一片连续的区域，这个区域叫数据段， 那些具有全局属性的但又未初始化的数据放在 bss 段。

![image-20230203232358377](C:\Users\86135\OneDrive\文档\数据结构与算法\LeetCode-img\14.png)



### 0.9物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别

- 物理地址：物理地址就是物理内存真正的地址，相当于内存中每个存储单元的门牌号，具有唯一性。不管在什么模式下，不管什么虚拟地址、线性地址，CPU 最终都要以物理地址去访问内存，只有物理地址才是内存访问的终点站。在实模式下，“段基址+段内偏移地址”经过段部件的处理，直接输出的就是物理地址，CPU 可以直 接用此地址访问内存。
- 线性地址：在保护模式下，“段基址+段内偏移地址”称为线性地址，不过，此时的段基址已经不再是真正的地址 了，而是一个称为选择子的东西。若没有开启地址分页功能， 此线性地址就被当作物理地址来用，可直接访问内存。若开启了分页功能，此线性地址又多了一个名字，就是虚拟地址（虚拟地址、线性地址在分页机制下都是一回事）。虚拟地址要经过 CPU 页部件转换成具体的物理地 址，这样 CPU 才能将其送上地址总线去访问内存。
- 逻辑地址：无论在实模式或是保护模式下，段内偏移地址又称为有效地址，也称为逻辑地址，这是程序员可见的地址。
- 虚拟地址：线性地址或称为虚拟地址，这都不是真实的内存地址。它们都用来描述程序或任务的地址空间。。由于分页功能是需要在保护模式下开启的，32 位系统保护模式下的寻址空间是4GB，所以虚拟地址或线性地址就是0～4GB 的范围。



### 0.10什么是段重叠

- 用这种“段基地址：段内偏移”的组合，0xC00：3 和 0xC02：1 是等价的，它们都访问到同一个物理内存块。



### 0.11什么是平坦模型

- 平坦模型是相对于多段模型来说的，所以说平坦模型指的就是一个段。



### 0.12cs、ds 这类sreg段寄存器，位宽是多少

- 在实模式下，CS、DS、ES、SS 中的值为段基址，是具体的物理地址，内存单元的逻辑地址仍为 “段基值：段内偏移量”的形式。在保护模式下，装入段寄存器的不再是段地址，而是“段选择子”（Selector）， 当然，选择子也是数值，其依然为 16 位宽度。



### 0.13什么是工程，什么是协议

- 软件中的工程是指开发一套软件所需要的全部文件，包括配置环境。
- 协议是一种大家共同遵守的规约，主要用来实现通信、共享、协作；起初是为避免大家各干各的，无 法彼此调用对方成果的情况，从而给大家统一一种接口、一组数据调用或者分析的约定。



### 0.14为什么Linux系统下的应用程序不能在Windows系统下运行

- 格式不同
- 系统API不同，API即Application Programming Interface，应用程序编程接口。

- 编译器
- 标准库



### 0.15局部变量和函数参数为什么要放在栈中

- 全局的变量，意味着谁 都可以随时随地访问，所以其放在数据段中。而局部变量只是自己在用，放在数据段中纯属浪费空间，没有必要，故将其放在自己的栈中，随时可以清理，真正体现了局部的意义。
- 堆是程序运行过程中用于动态内存分配的内存空间，是操作系统为每个用户进程规划的，属于软件范畴。栈是处理器运行必备的内存空间，是硬件必需的，但又是由软件（操作系统）提供的。
- 栈和堆栈都是指的栈，在 C 程序的内存布局中，由于 堆和栈的地址空间是接壤的，栈从高地址往低地址发展，堆是从低地址往高地址发展，堆和栈早晚会碰头，它 们各自的大小取决于实际的使用情况，界限并不明朗，所以这可能是堆栈常放在一直称呼的原因吧。
- 编译器为函数参数动态分配内存，也就是在每次调用函数时才为它在栈中分配内存。



### 0.19什么是大端字节序、小端字节序

- 小端：因为低位在低字节，强制转换数据型时不需要再调整字节了。
- 大端：有符号数，其字节最高位不仅表示数值本身，还起到了符号的作用。符号位固定为第一字 节，也就是最高位占据最低地址，符号直接可以取出来，容易判断正负。
