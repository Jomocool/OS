# 《操作系统真象还原》

## 第0章 一些你可能正感到迷惑的问题

### 0.1操作系统是什么

如果有一个部落，操作系统相当于管理部落的，协调部落各个人员，保证每天的生产工作有条不紊的进行着。具体一点的说，操作系统负责把资源交给用户进程，使用户进程可以专注于自己的工作，而不用考虑如何获取内存中需要的资源，同时为了保证资源的安全性和完整性，用户进程无法直接访问内存。

eg. Linux系统中的内存管理，分别记录哪些page是Active，哪些是“脏页”。但不记录也不会影响程序的正常运行，记录这些状态是为了更好地管理内存，比如结婚要登记，不登记也不影响两个人在一起，但是登记了方便预测国家未来人口趋势。



### 0.4软件是如何访问硬件

显卡是是显示器的适配器，CPU不直接和显示器交互，它只和显卡通信，显卡的内存叫显存，往显存上写字节就是往显示器打印内容。

访问IO接口本质上就是访问IO接口上的寄存器。



### 0.5应用程序是什么，和操作系统是如何配合到一起的

- 应用程序和操作系统都是软件。

- 操作系统是人想出来的，为了让自己管理计算机方便而创造出来的一套管理办法。

- 应用程序要用某种语言编写，而语言又是编译器来提供的。其实根本就没有什么语言，有的只是编译 器。是编译器决定怎样解释某种关键字及某种语法。

- 应用程序加上操作系统提供功能才算是完整的程序。

- 用户态与内核态是对 CPU 来讲的，是指 CPU 运行在用户态（特权 3 级）还是内核态（特权 0 级）， 很多人误以为是对用户进程来讲的。

- 用户进程陷入内核态是指：由于内部或外部中断发生，当前进程被暂时终止执行，其上下文被内核的 中断程序保存起来后，开始执行一段内核的代码。是内核的代码，不是用户程序在内核的代码，用户代码 怎么可能在内核中存在，所以“用户态与内核态”是对 CPU 来说的。操作系统是独立的部分，用户进程永远不会因为进入内核态而变身为操作系统了。（中断用户程序进程，运行内核程序进程，二者完全不同）

### 0.6为什么称为“陷入”内核

![image-20230129232924749](C:\Users\86135\OneDrive\文档\操作系统\OS-img\1.png)

用户程序想要访问系统资源时（无论是硬件，还是内核数据结构），需要进行系统调用。这样CPU就进入了内核态（需要CPU

需要去访问内存），也叫管态。



### 0.7内存访问为什么要分段

- 内存是随机读写设备，即访问其内部任何一处，不需要从头开始找，只需要直接给出地址即可。

- 分段是内存访问机制，是给CPU用的访问内存的方式，只有CPU才关注段。

- 历史遗留问题：之前的计算机没有虚拟地址一说，只有物理地址，于是程序的指令如果想要在硬件上运行，那也必须是绝对物理地址，就要遵从硬件的规则，操作系统和编译器也不例外。于是两个编译出来地址相同的用户程序无法同时运行，只能运行其中一个。

- 解决方式：让CPU采用“段基址+段内偏移地址”的方式来访问任意内存，使程序重定位。

- 重定位：将程序中的指令地址改写成另外一个地址，但新地址的内容还是原地址的内容。CPU 采用“段基址+段内偏移地址”的形式访问内存，就需要专门提供段基址寄存器，这些是 cs、ds、 es 等。程序中需要用到哪块内存，只要先加载合适的段到段基址寄存器中，再给出相对于该段基址的偏移 地址便可，CPU 中的地址单元会将这两个地址相加后的结果用于内存访问，送上地址总线。段基址可以是任意的，不一定要是65536的倍数，因此段可以重叠。

- 程序分段又是为了将大内存分成可以访问的小段， 通过这样变通的方法便能够访问到所有内存了。

- 1M 是 2 的 20 次方，1MB 内存需要 20 位的地址 才能访问到，如何做到用 16 位寄存器访问 20 位地址空间呢？

  这是因为 CPU 设计者在地址处理单元中动了手脚，该地址部件接到“段基址+段内偏移地址”的地址后， 自动将段基址乘以 16，即左移了 4 位，然后再和 16 位的段内偏移地址相加。

