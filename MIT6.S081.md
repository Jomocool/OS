# MIT6.S081

## Lecture 1 - Introduction and Examples

**fork()：**

fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。

一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。

1. 在父进程中，fork返回新创建子进程的进程ID
2. 在子进程中，fork返回0
3. 如果出现错误，fork返回一个负值



![image-20230319173008087](C:\Users\86135\OneDrive\文档\操作系统\MIT6.S081-img\1.png)

**执行过程：**

1. 从第12行开始，就有两个一模一样的进程了，其中一个为父进程，另一个为子进程
2. 父进程pid>0，子进程pid==0
3. 父进程执行完19行之后开始wait，子进程进行系统调用(15行)，调用成功，直接退出了，把返回值0写道&status上，之后父进程继续执行第21行

输出：
parent waiting

THIS IS ECHO

the child exited with status 0



![image-20230319173605104](C:\Users\86135\OneDrive\文档\操作系统\MIT6.S081-img\2.png)

xklsdksdjkecho不存在

输出：

parent waiting

exec failed

the child exited with status 1



以上的输出并不能保证每次都相同，因为每条命令的执行顺序并不能保证每次都是一样的。因为在执行exec时，操作系统需要先到磁盘中获取exec，接着释放旧进程的内存，时间开销相对大



- fork会复制整个父进程的内存，可能会造成内存浪费，但exec会扔掉所有复制的内存，并将其替换为你运行的文件的内容，因为进入到exec后，子进程将不会用到复制的内存了

- 如果一个父进程有多个子进程，就需要多个wait函数，每退出一个子进程，就返回一个wait，wait返回后，会显示子进程ID