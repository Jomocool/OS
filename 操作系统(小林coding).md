# 操作系统(小林coding)

## 一、硬件结构

### 1.1 CPU是如何执行程序的？

**冯诺依曼模型**

![image-20230516115743671](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516115743671.png)

定义了计算机基本结构

1. 中央处理器（CPU）
2. 内存
3. 输入设备
4. 输出设备
5. 总线



**内存**

程序和数据都是存储在内存的，存储的区域是线性的。

数据存储的单位是一个二进制位（bit），即0或1。最小的存储单位是字节（byte），1byte=8bit

内存的地址从0开始编号，然后递增排列，结构类似数组，因此内存读写任何一个数据的速度都是一样的



**中央处理器**（CPU）

32位和64位CPU最主要的区别在于一次能计算多少字节数据：

- 32位CPU一次可以计算4个字节
- 64位PU一次可以计算8个字节

32位和64位通常称为CPU的位宽

CPU这样的设计的原因是为了能计算更大的值，如果是8位CPU，一次只能计算1个字节，即0~255的范围，这样就无法一完成计算10000*500，于是为了能够一次计算大数的运算，CPU需要支持多个byte一起计算，因此CPU位宽越大，可以计算的数值也就越大。



CPU内部还有一些组件，常见的有寄存器、控制单元和逻辑运算单元等。

- 控制单元：负责控制CPU工作
- 逻辑运算单元：负责计算
- 寄存器：有多种类型，每种寄存器的功能不一样。主要储存计算时的数据，寄存器就在CPU里，且紧挨着控制单元和逻辑运算单元，计算速度更快。
  1. 通用寄存器：用来存放需要进行运算的数据
  2. 程序计数器：用来存储CPU要执行的下一条指令**所在的内存地址**，此时指令还在内存中
  3. 指令寄存器：用来存放程序计数器指向的指令，即指令本身，指令被执行完之前都存储在这里



***为什么有程序计数器存放下一条指令的内存地址，还需要指令寄存器呢？***

程序计数器和指令寄存器都是计算机中重要的寄存器之一，但是它们的作用是不同的。程序计数器用于存放下一条指令在内存中的地址，而指令寄存器则是用于存放当前正在执行的指令。

当计算机需要执行指令时，程序计数器会把下一条指令的地址取出来，然后将其存放到指令寄存器中，执行该指令后指令寄存器会自动移动到下一条指令的内存地址。这样计算机就能顺序执行程序中的指令了。

另外，指令寄存器还可以用于存放预取出的指令，这样可以提高指令的执行效率。当执行完当前指令后，指令寄存器可以直接取出预取出的指令执行，而不需要重新从内存中取出下一条指令的地址，从而节省了时间。



**总线**

总线用于CPU和内存以及其他设备之间的通信，可分为3种

- 地址总线：用于指定CPU将要操作的内存地址
- 数据总线：用于读写内存的数据
- 控制总线：用于发送和接收信号，比如中断、设备复位等信号，

当CPU要读写内存数据时，一般通过两个总线：

- 

- 首先通过地址总线指定内存地址
- 再通过数据总线来传输数据



**输入、输出设备**

输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。期间，如果输入设备是键盘，按下按键是需要和CPU进行交互的，此时就需要用到控制总线了。



**线路位宽与CPU位宽**

数据通过线路电压的变化来传输的，低电压表示0，高电压表示1

一位一位的传输方式称为串行，下一个bit必须等待上一个bit传输完成后才能进行传输。如果想一次传输多位数据，只需要增加线路即可，此时数据可以并行传输。

为了避免低效率的串行传输的方式，线路的位宽最好一次就能访问到所有的内存地址。CPU要想操作内存地址就需要总线，如果总线只有一条，那每次只能表示0或1这两种情况，所以CPU一次只能操作两个内存地址了，如果CPU要想操作4G的内存，就需要32条地址总线，因为log2(4G)=32

CPU的位宽最好不要小于线路位宽，32位CPU一次最多只能操作32位宽的地址总线和数据总线

如果计算的数额不超过2^32的情况下，32位和64位CPU之间的处理速度没什么区别

32位CPU最大只能操作4GB内存，就算有8GB内存条也没用，因为寻址不到。而64位CPU的理论最大寻址空间2^64



**程序执行的基本过程**

程序实际上是一条一条指令，程序的运行过程实际上就是一条一条执行指令，负责执行指令的就是CPU了

![](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516172737104.png)

1. CPU获取程序计数器的值，该值是指令的内存地址，然后CPU的控制单元通过操作地址总线指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过数据总线将指令数据传给CPU，CPU接收到内存传来的地址后，将这个指令数据存入到指令寄存器
2. CPU分析指令寄存器中的指令，确定之类的类型和参数，如果是计算类型的指令，就把指令交给逻辑运算单元运算；如果是存储类型的指令，则交给控制单元执行
3. CPU执行完指令后，程序计数器的值自增，表示指向下一条指令。自增的大小由CPU的位宽决定，比如32位的CPU，指令是4个字节，需要4个内存地址存放，因此程序计数器的值会增加4

总结：一个从程序执行的时候，CPU会根据程序计数器的内存地址，从内存里把需要执行的指令读取到指令寄存器里面指向。然后根据指令长度自增，即自增到下一个指令内存地址，然后又开始循环反复



**a=1+2的执行具体过程**

CPU不认识a=1+2这个字符串，这个字符串只是方便我们程序员认识。要想将这段程序跑起来，还需要把整个程序编译成汇编代码。

针对汇编代码，还需要把汇编代码翻译成机器码，即由0和1组成的机器语言。

程序编译过程中，编译器通过分析代码，发现1和2是数据，于是程序运行时，内存会有个专门的区域来存放这些数据，这个区域就是**数据段**，注意，数据和指令是分开区域存放的，存放指令区域的地方叫做**正文段**，如下图

![image-20230516175213486](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516175213486.png)

![image-20230516175315117](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516175315117.png)

注意，以上是编译器干的事

由于是在32位CPU执行的，因此一条指令是占32位大小，所以每条指令间隔4个字节

而数据的大小是根据程序中指定的变量类型，比如int类型的数据占4个字节，char类型的数据占1个字节



**指令**

上图中的指令内容实际上是一串二进制数字的机器码，简易的汇编代码实际上只是方便我们理解

不同的CPU有不同的指令集，也就对应着不同的汇编语言和不同的机器码

![image-20230516175730079](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516175730079.png)

- R指令：用在算数和逻辑操作，里面有读取和写入数据的寄存器地址。如果是逻辑位移操作，后面还有位移操作的位移量，而最后的功能码则是再前面的操作码不够时，扩展操作码；来表示对应的具体指令
- I指令：用在数据传输、条件分支等。这个类型的指令，就没有了位移量和操作码，也没有了第三个寄存器，而是把这三部分直接合并成了一个地址值或一个常数
- J指令：用在跳转，高6位之外的26位都是一个跳转的目标地址

![image-20230516180206781](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516180206781.png)

编译器在编译程序时会构造指令，这个过程叫做指令的编码。CPU执行程序时，就会解析指令，这个过程叫做指令的解码。

现代大多数CPU都使用流水线的方式来执行指令，所谓的流水线实际上就是把一个任务拆分成多个小任务，于是一条指令通常分为4个阶段，称为4级流水线，如下图：
![image-20230516180526634](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516180526634.png)

1. Fetch：CPU通过程序计数器读取对应内存地址的指令
2. Decode：CPU对指令进行解码
3. Execute：CPU执行指令
4. Store：CPU将计算结果存回寄存器或者将寄存器的值存入内存

这4个阶段，称为指令周期（Instruction Cycle），CPU的工作就是一个周期接着一个周期，周而复始

实际上，不同阶段其实是由计算机中不同组件完成的

![image-20230516180919407](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516180919407.png)



**指令的类型**

![image-20230516181111705](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516181111705.png)



**指令的执行速度**

![image-20230516181343630](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516181343630.png)

假设CPU的主频是2.4GHz，意味着1秒钟会产生2.4G次的脉冲信号，则时钟周期时间是(1/2.4G)s

提升CPU执行效率可以从两方面入手：

1. 降低时钟周期时间，即提高CPU主频，但今非昔比，摩尔定律早已失效，CPU主频很难再做到翻倍成长
2. 降低CPU时钟周期数

CPU时钟周期数可以拆解成 指令数*每条指令的平均时钟周期数（Cycles Per Instruction，简称CPI）

![image-20230516181942446](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516181942446.png)

![image-20230516182130394](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516182130394.png)



**总结**

![image-20230516183411326](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516183411326.png)



### 1.2 存储器金字塔

内存和硬盘都属于计算机的存储设备，断电后内存的数据是会丢失的，而硬盘不会，因为硬盘是持久化存储设备，同时也是一个I/O设备

CPU内部也有存储数据的组件，比如寄存器、CPU的L1/L2/L3 Cache，只不过存储的数据非常小，但又因为接近CPU核心，所以访问速度很快，比硬盘快好几个数量级



**存储器的层次结构**

1. CPU内部

   - CPU：大脑

   - CPU中的寄存器：大脑正在思考的东西，处理速度最快，但是能存储的数据也是最少的

   - CPU Cache：大脑中的记忆

     ——L1 Cache：数据存储和指令存储，L1距离CPU最近，所以它比L2、L3的读写速度都更快、存储空间更小

     ——L2/L3 Cache：大脑中的长期记忆

     寄存器和CPU Cache都在CPU内部，跟CPU距离近，因此读写速度都快，但是内存小

2. CPU外部

   - 内存：书桌上的书，虽然一伸手就可以拿到，但是读写速度远慢于寄存器
   - 硬盘：图书馆书架上的书，能存储的数据十分大，但是读写速度比内存差好几个数量级

   ![image-20230518230811525](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230518230811525.png)

从图书馆书架取书，把书放到桌子上，再阅读书，大脑记忆知识点，然后经过大脑思考。这一过程相当于从硬盘加载到内存，再从内存加载到CPU的寄存器和Cache中，然后再通过CPU进行处理和计算

对于存储器，速度越快 -> 能耗越高 -> 材料成本越贵，所以速度快的存储器容量都比较小

存储器可以分为以下几个级别：

- 寄存器
- CPU Cache：
  1. L1-Cache
  2. L2-Cache
  3. L3-Cache
- 内存
- SSD/HDD硬盘



**寄存器**

最靠近CPU控制单元和逻辑计算单元的存储器

- 32位CPU中大多数寄存器可以存储4个字节
- 64位CPU中大多数寄存器可以存储8个字节

寄存器的访问速度非常快，一般要求在半个CPU时钟周期内完成读写，CPU时钟周期跟CPU主频息息相关，比如2GHz主频的CPU的时钟周期就是1/2G，也就是0.5ns

CPU处理一条指令的时候，除了读写寄存器，还需要解码指令、控制指令执行和计算。如果寄存器的速度太慢，则会拉长指令的处理周期，从而给用户感觉电脑"很慢"



**CPU Cache**

CPU Cache用的是一种叫SRAM(Static Random-Access Memory，静态随机存储器)的芯片

SRAM之所以叫静态存储器，是因为只要有电，数据就可以保持存在，而一旦断电，数据就会丢失了

在SRAM中，一个bit的数据，通常需要6晶体管，所以SRAM存储密度不高，同样的物理空间下，能存储的数据有限，不过因为SRAM电路简单，所以访问速度非常快

![image-20230519103257378](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230519103257378.png)



**L1高速缓存**

L1高速缓存的访问速度几乎和寄存器一样快，通常只需要2~4个时钟周期，大小在几十KB到几百KB不等

每个CPU核心都有一块属于自己的L1高速缓存，指令和数据在L1是分开存放的，所以L1高速缓存通常分成指令缓存和数据缓存



**L2高速缓存**

L2高速缓存同样存在于每个CPU核心，但离CPU核心的位置比L1更远，但大小比L1大，CPU型号不同大小也不同，通常在几百KB到几MB不等，访问速度更慢，在10~20个时钟周期



**L3高速缓存**

L3高速缓存通常是多个CPU核心共用，位置比L2高速缓存距离CPU核心更远，但大小更大，通常在几MB到几十MB不等，访问速度在20~60个时钟周期



**内存**

内存使用DRAM(Dynamic Random Access Memory，动态随机存取存储器)的芯片

相比SRAM，DRAM的密度更高，功耗更低，有更大的容量，而且造价比SRAM芯片便宜很多

DRAM存储一个bit数据，只需要一个晶体管和一个电容，但是因为数据会被存储在电容里，电容会不断漏电，所以需要定时刷新电容，才能保证数据不会丢失，这就是DRAM被称为动态存储器的原因，只有不断刷新，数据才不会丢失，才能够存储起来

DRAM的数据访问电路和刷新电路都比SRAM更复杂，所以访问速度会更慢，内存速度大概在200~300个时钟周期



**SSD/HDD硬盘**

SSD（Solid-state disk），固体硬盘，结构和内存类似，但是它相比内存的优点是断电后数据还在，而内存、寄存器、高速缓存断电后数据都会丢失。内存读写的速度比SSD快10~1000倍

还有一种传统硬盘，即机械硬盘（Hard Disk Drive，HDD），通过物理读写的方式来访问数据，因此访问速度非常慢，比内存慢10w倍左右

由于SSD价格接近机械硬盘，因此机械硬盘已经逐渐被SSD替代了



**存储器的层次关系**

CPU并不会直接和每一种存储器设备直接打交道，而是每一种存储器设备只和它相邻的存储器设备打交道

![image-20230519205756455](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230519205756455.png)

当CPU需要访问内存中的某个数据时，如果寄存器有这个数据，CPU直接从寄存器取数据即可，如果寄存器没有这个数据，CPU就会查询L1高速缓存，如果L1没有，则查询L2高速缓存，L2还是没有就查询L3高速缓存，L3依然没有的话，才去内存中取数据。（顿时理解了为什么传的是地址而不是其它了，因为地址是唯一的，不会出现歧义，而值可能有相等的两个值出现的情况）所以，存储层次结构也形成了缓存的体系



**存储器之间的实际价格和性能差距**

![image-20230519235919850](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230519235919850.png)



**总结**

不同的存储器之间性能差距很大，构造存储器分级很有意义，分级的目的是要构造缓存体系

