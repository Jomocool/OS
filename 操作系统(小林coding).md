# 操作系统(小林coding)

## 一、硬件结构

### 1.1 CPU是如何执行程序的？

**冯诺依曼模型**

![image-20230516115743671](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516115743671.png)

定义了计算机基本结构

1. 中央处理器（CPU）
2. 内存
3. 输入设备
4. 输出设备
5. 总线



**内存**

程序和数据都是存储在内存的，存储的区域是线性的。

数据存储的单位是一个二进制位（bit），即0或1。最小的存储单位是字节（byte），1byte=8bit

内存的地址从0开始编号，然后递增排列，结构类似数组，因此内存读写任何一个数据的速度都是一样的



**中央处理器**（CPU）

32位和64位CPU最主要的区别在于一次能计算多少字节数据：

- 32位CPU一次可以计算4个字节
- 64位PU一次可以计算8个字节

32位和64位通常称为CPU的位宽

CPU这样的设计的原因是为了能计算更大的值，如果是8位CPU，一次只能计算1个字节，即0~255的范围，这样就无法一完成计算10000*500，于是为了能够一次计算大数的运算，CPU需要支持多个byte一起计算，因此CPU位宽越大，可以计算的数值也就越大。



CPU内部还有一些组件，常见的有寄存器、控制单元和逻辑运算单元等。

- 控制单元：负责控制CPU工作
- 逻辑运算单元：负责计算
- 寄存器：有多种类型，每种寄存器的功能不一样。主要储存计算时的数据，寄存器就在CPU里，且紧挨着控制单元和逻辑运算单元，计算速度更快。
  1. 通用寄存器：用来存放需要进行运算的数据
  2. 程序计数器：用来存储CPU要执行的下一条指令**所在的内存地址**，此时指令还在内存中
  3. 指令寄存器：用来存放程序计数器指向的指令，即指令本身，指令被执行完之前都存储在这里



***为什么有程序计数器存放下一条指令的内存地址，还需要指令寄存器呢？***

程序计数器和指令寄存器都是计算机中重要的寄存器之一，但是它们的作用是不同的。程序计数器用于存放下一条指令在内存中的地址，而指令寄存器则是用于存放当前正在执行的指令。

当计算机需要执行指令时，程序计数器会把下一条指令的地址取出来，然后将其存放到指令寄存器中，执行该指令后指令寄存器会自动移动到下一条指令的内存地址。这样计算机就能顺序执行程序中的指令了。

另外，指令寄存器还可以用于存放预取出的指令，这样可以提高指令的执行效率。当执行完当前指令后，指令寄存器可以直接取出预取出的指令执行，而不需要重新从内存中取出下一条指令的地址，从而节省了时间。



**总线**

总线用于CPU和内存以及其他设备之间的通信，可分为3种

- 地址总线：用于指定CPU将要操作的内存地址
- 数据总线：用于读写内存的数据
- 控制总线：用于发送和接收信号，比如中断、设备复位等信号，

当CPU要读写内存数据时，一般通过两个总线：

- 

- 首先通过地址总线指定内存地址
- 再通过数据总线来传输数据



**输入、输出设备**

输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。期间，如果输入设备是键盘，按下按键是需要和CPU进行交互的，此时就需要用到控制总线了。



**线路位宽与CPU位宽**

数据通过线路电压的变化来传输的，低电压表示0，高电压表示1

一位一位的传输方式称为串行，下一个bit必须等待上一个bit传输完成后才能进行传输。如果想一次传输多位数据，只需要增加线路即可，此时数据可以并行传输。

为了避免低效率的串行传输的方式，线路的位宽最好一次就能访问到所有的内存地址。CPU要想操作内存地址就需要总线，如果总线只有一条，那每次只能表示0或1这两种情况，所以CPU一次只能操作两个内存地址了，如果CPU要想操作4G的内存，就需要32条地址总线，因为log2(4G)=32

CPU的位宽最好不要小于线路位宽，32位CPU一次最多只能操作32位宽的地址总线和数据总线

如果计算的数额不超过2^32的情况下，32位和64位CPU之间的处理速度没什么区别

32位CPU最大只能操作4GB内存，就算有8GB内存条也没用，因为寻址不到。而64位CPU的理论最大寻址空间2^64



**程序执行的基本过程**

程序实际上是一条一条指令，程序的运行过程实际上就是一条一条执行指令，负责执行指令的就是CPU了

![](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516172737104.png)

1. CPU获取程序计数器的值，该值是指令的内存地址，然后CPU的控制单元通过操作地址总线指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过数据总线将指令数据传给CPU，CPU接收到内存传来的地址后，将这个指令数据存入到指令寄存器
2. CPU分析指令寄存器中的指令，确定之类的类型和参数，如果是计算类型的指令，就把指令交给逻辑运算单元运算；如果是存储类型的指令，则交给控制单元执行
3. CPU执行完指令后，程序计数器的值自增，表示指向下一条指令。自增的大小由CPU的位宽决定，比如32位的CPU，指令是4个字节，需要4个内存地址存放，因此程序计数器的值会增加4

总结：一个从程序执行的时候，CPU会根据程序计数器的内存地址，从内存里把需要执行的指令读取到指令寄存器里面指向。然后根据指令长度自增，即自增到下一个指令内存地址，然后又开始循环反复



**a=1+2的执行具体过程**

CPU不认识a=1+2这个字符串，这个字符串只是方便我们程序员认识。要想将这段程序跑起来，还需要把整个程序编译成汇编代码。

针对汇编代码，还需要把汇编代码翻译成机器码，即由0和1组成的机器语言。

程序编译过程中，编译器通过分析代码，发现1和2是数据，于是程序运行时，内存会有个专门的区域来存放这些数据，这个区域就是**数据段**，注意，数据和指令是分开区域存放的，存放指令区域的地方叫做**正文段**，如下图

![image-20230516175213486](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516175213486.png)

![image-20230516175315117](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516175315117.png)

注意，以上是编译器干的事

由于是在32位CPU执行的，因此一条指令是占32位大小，所以每条指令间隔4个字节

而数据的大小是根据程序中指定的变量类型，比如int类型的数据占4个字节，char类型的数据占1个字节



**指令**

上图中的指令内容实际上是一串二进制数字的机器码，简易的汇编代码实际上只是方便我们理解

不同的CPU有不同的指令集，也就对应着不同的汇编语言和不同的机器码

![image-20230516175730079](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516175730079.png)

- R指令：用在算数和逻辑操作，里面有读取和写入数据的寄存器地址。如果是逻辑位移操作，后面还有位移操作的位移量，而最后的功能码则是再前面的操作码不够时，扩展操作码；来表示对应的具体指令
- I指令：用在数据传输、条件分支等。这个类型的指令，就没有了位移量和操作码，也没有了第三个寄存器，而是把这三部分直接合并成了一个地址值或一个常数
- J指令：用在跳转，高6位之外的26位都是一个跳转的目标地址

![image-20230516180206781](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516180206781.png)

编译器在编译程序时会构造指令，这个过程叫做指令的编码。CPU执行程序时，就会解析指令，这个过程叫做指令的解码。

现代大多数CPU都使用流水线的方式来执行指令，所谓的流水线实际上就是把一个任务拆分成多个小任务，于是一条指令通常分为4个阶段，称为4级流水线，如下图：
![image-20230516180526634](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516180526634.png)

1. Fetch：CPU通过程序计数器读取对应内存地址的指令
2. Decode：CPU对指令进行解码
3. Execute：CPU执行指令
4. Store：CPU将计算结果存回寄存器或者将寄存器的值存入内存

这4个阶段，称为指令周期（Instruction Cycle），CPU的工作就是一个周期接着一个周期，周而复始

实际上，不同阶段其实是由计算机中不同组件完成的

![image-20230516180919407](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516180919407.png)



**指令的类型**

![image-20230516181111705](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516181111705.png)



**指令的执行速度**

![image-20230516181343630](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516181343630.png)

假设CPU的主频是2.4GHz，意味着1秒钟会产生2.4G次的脉冲信号，则时钟周期时间是(1/2.4G)s

提升CPU执行效率可以从两方面入手：

1. 降低时钟周期时间，即提高CPU主频，但今非昔比，摩尔定律早已失效，CPU主频很难再做到翻倍成长
2. 降低CPU时钟周期数

CPU时钟周期数可以拆解成 指令数*每条指令的平均时钟周期数（Cycles Per Instruction，简称CPI）

![image-20230516181942446](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516181942446.png)

![image-20230516182130394](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516182130394.png)



**总结**

![image-20230516183411326](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230516183411326.png)
