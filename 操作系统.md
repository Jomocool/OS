# 操作系统

## 操作系统的启动

1. 按电源键

2. CPU、Memory、IO

3. POST(加电自检)、寻找显卡、执行BIOS(基本IO处理系统)：检测基本外设

4. BIOS加载Boothloader

5. Boothloader(存放在第一个磁盘的第一个扇区(512B))：加载OS(让存放在Disk的OS加载到Memory中，让CPU可以执行操作系统)

   ![image-20230216234724812](C:\Users\86135\OneDrive\文档\操作系统\OS-img\1.png)

   ![image-20230216235839090](C:\Users\86135\OneDrive\文档\操作系统\OS-img\2.png)



## 操作系统与设备和程序交互

- **系统调佣(来源于应用程序)：**应用程序主动向操作系统发出服务请求
- **异常(来源于不良的应用程序)：**非法指令或者其他坏的处理状态(如：内存出错)
- **中断(来源于外设)：**来自不同的硬件设备的计时器和网络的中断



- **在计算机运行中，内核是被信任的第三方：**程序只能通过操作系统访问外设，而不能直接访问外设
- **只有内核可以执行特权指令**
- **为了方便应用程序：**通过操作系统可以让程序屏蔽底层设备的差异性



- **源头：**
  - **中断：**外设
  - **异常：**应用程序意想不到的行为
  - **系统调用：**应用程序请求操作提供服务
- **处理时间：**
  - **中断：**异步(应用程序不确定什么时候会发生)
  - **异常：**同步(特定指令触发，应用程序知道什么时候会发生)
  - **系统调用：**异步或同步(发出请求的时间点是同步的，返回点可能是异步的)
- **响应：**
  - **中断：**持续，对用户应用程序是透明的
  - **异常：**杀死或重新执行意想不到的应用程序指令
  - **系统调用：**等待和持续



## 操作系统的中断、异常和系统调用

### 中断

**硬件：**

- **设计中断标记[CPU初始化]：**
  1. 将内部、外部事件设置中断标记
  2. 中断事件的ID

**软件(OS)：**

- 保存当前处理状态
- 中断服务程序处理
- 清除中断标记
- 恢复之前保存的处理状态

### **异常**

- **异常：**异常编号
  - 保存现场
  - 异常处理
    - 杀死产生了异常的程序
    - 修复异常，然后重新执行异常指令
  - 恢复现场



**中断和异常对于应用程序来说是透明的，因为出现这两种情况应用程序相当于“睡过去了”**

### 系统调用

**系统调用：**

- 应用程序需要我们操作系统提供服务，但这些服务无法由应用程序直接指行，所以有一个系统调用接口
- 程序访问主要是通过高层次的API接口而不是直接进行系统调用

![image-20230217141919524](C:\Users\86135\OneDrive\文档\操作系统\OS-img\3.png)

![image-20230217142138038](C:\Users\86135\OneDrive\文档\操作系统\OS-img\4.png)

![image-20230217142300495](C:\Users\86135\OneDrive\文档\操作系统\OS-img\5.png)

**应用程序处于用户态，无法控制整个计算机**

**操作系统处于内核态，可以控制整个计算机**



应用程序执行系统调用时，从用户态切换到内核态，特权级改变，堆栈从应用程序切换到操作系统也要进行转换，时间上会有额外开销，但是安全可靠。

![image-20230217142950615](C:\Users\86135\OneDrive\文档\操作系统\OS-img\6.png)

正因为有这些检测，使得跨越操作系统边界更加安全可靠



## 计算机体系结构及内存分层体系

![image-20230219110351458](C:\Users\86135\OneDrive\文档\操作系统\OS-img\7.png)

![image-20230219110451725](C:\Users\86135\OneDrive\文档\操作系统\OS-img\8.png)

![image-20230219110711788](C:\Users\86135\OneDrive\文档\操作系统\OS-img\9.png)

- 在操作系统中管理内存的不同方法
  - 程序重定位
  - 分段
  - 分页
  - 虚拟内存
  - 按需分页虚拟内存
- 实现高度依赖于硬件
  - 必须知道内存架构
  - MMU（内存管理单元）：硬件组件负责处理CPU的内存访问请求



## 地址空间与地址生成

![image-20230219111427889](C:\Users\86135\OneDrive\文档\操作系统\OS-img\10.png)

![image-20230219122039121](C:\Users\86135\OneDrive\文档\操作系统\OS-img\11.png)

逻辑地址和物理地址的映射关系由操作系统完成

![image-20230219122310835](C:\Users\86135\OneDrive\文档\操作系统\OS-img\12.png)



## 连续内内分配：内寸碎片与分区的动态分配

- **内存碎片问题：**

  - 空闲内存不能被利用
  - 外部碎片：在分配单元间的未使用内存
  - 内部碎片：在分配单元中的未使用内存

- **分区的动态分配：**

  ![image-20230219122714798](C:\Users\86135\OneDrive\文档\操作系统\OS-img\13.png)

  **首次适配：**

  ![image-20230219122928543](C:\Users\86135\OneDrive\文档\操作系统\OS-img\14.png)

  ![image-20230219123737761](C:\Users\86135\OneDrive\文档\操作系统\OS-img\15.png)

  **最优适配(best fit)：**

  ![image-20230219123854939](C:\Users\86135\OneDrive\文档\操作系统\OS-img\16.png)

  **最差适配(worst fit)：**

  ![image-20230219124023869](C:\Users\86135\OneDrive\文档\操作系统\OS-img\17.png)

  ![image-20230219124105038](C:\Users\86135\OneDrive\文档\操作系统\OS-img\18.png)



## 连续内存分配：压缩式与交换式碎片整理

- **压缩式碎片整理：**

  - 重置程序以合并孔洞

  - 要求所有程序是 动态可重置的

    ![image-20230219125056721](C:\Users\86135\OneDrive\文档\操作系统\OS-img\19.png)

- **交换式碎片整理：**

  - 运行程序需要更多的内存

  - 抢占等待的程序和回收它们的内存

    ![image-20230219125117184](C:\Users\86135\OneDrive\文档\操作系统\OS-img\20.png)

