# 操作系统

## 操作系统的启动

1. 按电源键

2. CPU、Memory、IO

3. POST(加电自检)、寻找显卡、执行BIOS(基本IO处理系统)：检测基本外设

4. BIOS加载Boothloader

5. Boothloader(存放在第一个磁盘的第一个扇区(512B))：加载OS(让存放在Disk的OS加载到Memory中，让CPU可以执行操作系统)

   ![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/1.png)

   ![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/2.png)



## 操作系统与设备和程序交互

- **系统调佣(来源于应用程序)：**应用程序主动向操作系统发出服务请求
- **异常(来源于不良的应用程序)：**非法指令或者其他坏的处理状态(如：内存出错)
- **中断(来源于外设)：**来自不同的硬件设备的计时器和网络的中断



- **在计算机运行中，内核是被信任的第三方：**程序只能通过操作系统访问外设，而不能直接访问外设
- **只有内核可以执行特权指令**
- **为了方便应用程序：**通过操作系统可以让程序屏蔽底层设备的差异性



- **源头：**
  - **中断：**外设
  - **异常：**应用程序意想不到的行为
  - **系统调用：**应用程序请求操作提供服务
- **处理时间：**
  - **中断：**异步(应用程序不确定什么时候会发生)
  - **异常：**同步(特定指令触发，应用程序知道什么时候会发生)
  - **系统调用：**异步或同步(发出请求的时间点是同步的，返回点可能是异步的)
- **响应：**
  - **中断：**持续，对用户应用程序是透明的
  - **异常：**杀死或重新执行意想不到的应用程序指令
  - **系统调用：**等待和持续



## 操作系统的中断、异常和系统调用

### 中断

**硬件：**

- **设计中断标记[CPU初始化]：**
  1. 将内部、外部事件设置中断标记
  2. 中断事件的ID

**软件(OS)：**

- 保存当前处理状态
- 中断服务程序处理
- 清除中断标记
- 恢复之前保存的处理状态

### **异常**

- **异常：**异常编号
  - 保存现场
  - 异常处理
    - 杀死产生了异常的程序
    - 修复异常，然后重新执行异常指令
  - 恢复现场



**中断和异常对于应用程序来说是透明的，因为出现这两种情况应用程序相当于“睡过去了”**

### 系统调用

**系统调用：**

- 应用程序需要我们操作系统提供服务，但这些服务无法由应用程序直接指行，所以有一个系统调用接口
- 程序访问主要是通过高层次的API接口而不是直接进行系统调用

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/3.png)

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/4.png)

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/5.png)

**应用程序处于用户态，无法控制整个计算机**

**操作系统处于内核态，可以控制整个计算机**



应用程序执行系统调用时，从用户态切换到内核态，特权级改变，堆栈从应用程序切换到操作系统也要进行转换，时间上会有额外开销，但是安全可靠。

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/6.png)

正因为有这些检测，使得跨越操作系统边界更加安全可靠



## 计算机体系结构及内存分层体系

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/7.png)

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/8.png)

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/9.png)

- 在操作系统中管理内存的不同方法
  - 程序重定位
  - 分段
  - 分页
  - 虚拟内存
  - 按需分页虚拟内存
- 实现高度依赖于硬件
  - 必须知道内存架构
  - MMU（内存管理单元）：硬件组件负责处理CPU的内存访问请求



## 地址空间与地址生成

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/10.png)

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/11.png)

逻辑地址和物理地址的映射关系由操作系统完成

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/12.png)



## 连续内内分配：内寸碎片与分区的动态分配

- **内存碎片问题：**

  - 空闲内存不能被利用
  - 外部碎片：在分配单元间的未使用内存
  - 内部碎片：在分配单元中的未使用内存

- **分区的动态分配：**

  ![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/13.png)

  **首次适配：**

  ![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/14.png)

  ![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/15.png)

  **最优适配(best fit)：**

  ![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/16.png)

  **最差适配(worst fit)：**

  ![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/17.png)

  ![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/18.png)



## 连续内存分配：压缩式与交换式碎片整理

- **压缩式碎片整理：**

  - 重置程序以合并孔洞

  - 要求所有程序是 动态可重置的

    ![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/19.png)

- **交换式碎片整理：**

  - 运行程序需要更多的内存

  - 抢占等待的程序和回收它们的内存

    ![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/20.png)

## 非连续内存分配：分段

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/21.png)

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/22.png)

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/23.png)

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/24.png)

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/25.png)

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/26.png)

在正式寻址之前，操作系统就把段表建立好了。



## 非连续内存分配：分页

- **物理地址：**

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/27.png)

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/28.png)

页数：2^F

页帧(每一页的大小)：2^S

诊内偏移(页内偏移)：o

物理地址：2^S*f+o，表明那一块字节(byte)在哪。一般用二元组(f,o)表示

- **逻辑地址：**

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/29.png)

逻辑地址和物理地址的页数可以不同(即P可以不等于F)，但是页帧一定相同，方便设计硬件。

- **页寻址机制：**

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/30.png)

段的大小不一致，而页的大小一致，所以在硬件方面，实现页会比实现段更加简洁

![](https://github.com/Jomocool/Operator-System/blob/main/OS-img/31.png)

逻辑地址连续，但是映射到物理地址后就不一定连续了，有助于减少碎片
